# 3. Longest Substring Without Repeating Characters

## The Problem

Given a string `s`, find the length of the **longest**

**substring**

without repeating characters.

**Example 1:**

```
<strong>Input:</strong> s = "abcabcbb"
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is "abc", with the length of 3.
```

**Example 2:**

```
<strong>Input:</strong> s = "bbbbb"
<strong>Output:</strong> 1
<strong>Explanation:</strong> The answer is "b", with the length of 1.
```

**Example 3:**

```
<strong>Input:</strong> s = "pwwkew"
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

### My Initial Approach

**The Breakdown**
Before starting, its important to note that we are looking for a **substring** and **not a subsequence**.

**Substring vs. Subsequence**

A **Substring** is a sequence of characters in a string between two specified indices in a *contiguous* (no spaces in-between) order.

A **Subsequence** of a given string is generated by deleting some or no character of said string **without changing the order of the remaining elements**. It can contain consecutive elements that were not contiguous in the original sequence. It can also be an empty string. 

Example: 
```
Input: “apb”  Output: “a,” “p,” “b,” “ap,” “pb,” “ab,” “apb,” and. “”
```

In this problem we want to find the longest length substring without any repeated characters.

My initial thought is to use a hashset for tracking seen characters, and to use the **sliding-window** approach.

I will keep a count called `maxLength` starting at `0`.
I will also keep a set for seen characters called `seen`.
I think I can start iterating over the length of the string from the first character. At each iteration if the character `c` is **not** in the set `seen`, I will add it to the set, and set `maxLength` to be `Math.max(maxLength, seen.size)`.

If chararacter `c` **is** in `seen` it means we have found a repeating character. At this point, I think I can *empty* the set `seen` and start fresh by adding the previously already seen character `c` to the reset set. I am doing this to becuase each substring needs to have unique characters, if a repeating one is found, then the set (which is representing our substring here) needs to be reset, so we can start building a new one and then comparing its length (length of seen) to the current `maxLength`.

So implmenting this at first worked for the first 3 test cases. I originally used a for loop, and clearing the entire set would work **if each newly considered substring started with the repeated character**... but this assumption is wrong. If I have the string "dvdfa", when I get to character "d" (2nd) clearing the entire set `seen` so far would remove "dv" from the string "dvdfa"... This is wrong because only the character "d" is repeated so far. Clearing the entire set would incorrectly remove "v" which has not been seen yet, and should start as the beginning of the next valid substring.

To do this instead. I need to use a `start` and `end` pointer. The pointer `end` starts at 0 and serves as the current character `c` we are looking at. If `c` is already in `seen`, then we delete the character `s[start` in the set `seen` **until end is no longer in the set**. This means we may delete unique characters along the way, but this is ok, because the next valid substring should be one that doesnt include the repeated character we have found.

### My Solution

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let maxLength = 0;
    let seen = new Set();
    let start = 0, end = 0;

    while(end < s.length) {
        if(!seen.has(s[end])) {
            seen.add(s[end++]);
            maxLength = Math.max(maxLength, seen.size);
        }
        else {
            seen.delete(s[start++]);
            // seen.add(s[i]);
        }
    }

    return maxLength;
};
```




